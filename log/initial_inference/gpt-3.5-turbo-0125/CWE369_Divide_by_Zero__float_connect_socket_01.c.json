{
    "response": {
        "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE369_Divide_by_Zero__float_connect_socket_01.c\nLabel Definition File: CWE369_Divide_by_Zero__float.label.xml\nTemplate File: sources-sinks-01.tmpl.c\n*/\n/*\n * @description\n * CWE: 369 Divide by Zero\n * BadSource: connect_socket Read data using a connect socket (client side)\n * GoodSource: A hardcoded non-zero number (two)\n * Sinks:\n *    GoodSink: Check value of or near zero before dividing\n *    BadSink : Divide a constant by data\n * Flow Variant: 01 Baseline\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <math.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else /* NOT _WIN32 */\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define CHAR_ARRAY_SIZE 20\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifndef OMITBAD\n\nvoid CWE369_Divide_by_Zero__float_connect_socket_01_bad()\n{\n    float data;\n    /* Initialize data */\n    data = 0.0F;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* POTENTIAL FLAW: Use a value input from the network */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to float */\n            data = (float)atof(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        int result = (int)(100.0 / data);\n        printIntLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    float data;\n    /* Initialize data */\n    data = 0.0F;\n    /* FIX: Use a hardcoded number that won't a divide by zero */\n    data = 2.0F;\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        int result = (int)(100.0 / data);\n        printIntLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    float data;\n    /* Initialize data */\n    data = 0.0F;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* POTENTIAL FLAW: Use a value input from the network */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to float */\n            data = (float)atof(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* FIX: Check for value of or near zero before dividing */\n    if(fabs(data) > 0.000001)\n    {\n        int result = (int)(100.0 / data);\n        printIntLine(result);\n    }\n    else\n    {\n        printLine(\"This would result in a divide by zero\");\n    }\n}\n\nvoid CWE369_Divide_by_Zero__float_connect_socket_01_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE369_Divide_by_Zero__float_connect_socket_01_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE369_Divide_by_Zero__float_connect_socket_01_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n",
        "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  \n18  #include \"std_testcase.h\"\n19  \n20  #include <math.h>\n21  \n22  #ifdef _WIN32\n23  #include <winsock2.h>\n24  #include <windows.h>\n25  #include <direct.h>\n26  #pragma comment(lib, \"ws2_32\") \n27  #define CLOSE_SOCKET closesocket\n28  #else \n29  #include <sys/types.h>\n30  #include <sys/socket.h>\n31  #include <netinet/in.h>\n32  #include <arpa/inet.h>\n33  #include <unistd.h>\n34  #define INVALID_SOCKET -1\n35  #define SOCKET_ERROR -1\n36  #define CLOSE_SOCKET close\n37  #define SOCKET int\n38  #endif\n39  \n40  #define TCP_PORT 27015\n41  #define CHAR_ARRAY_SIZE 20\n42  #define IP_ADDRESS \"127.0.0.1\"\n43  \n44  #ifndef OMITBAD\n45  \n46  void CWE369_Divide_by_Zero__float_connect_socket_01_hoo()\n47  {\n48      float data;\n49      \n50      data = 0.0F;\n51      {\n52  #ifdef _WIN32\n53          WSADATA wsaData;\n54          int wsaDataInit = 0;\n55  #endif\n56          int recvResult;\n57          struct sockaddr_in service;\n58          SOCKET connectSocket = INVALID_SOCKET;\n59          char inputBuffer[CHAR_ARRAY_SIZE];\n60          do\n61          {\n62  #ifdef _WIN32\n63              if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n64              {\n65                  break;\n66              }\n67              wsaDataInit = 1;\n68  #endif\n69              connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n70              if (connectSocket == INVALID_SOCKET)\n71              {\n72                  break;\n73              }\n74              memset(&service, 0, sizeof(service));\n75              service.sin_family = AF_INET;\n76              service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n77              service.sin_port = htons(TCP_PORT);\n78              if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n79              {\n80                  break;\n81              }\n82              \n83  \n84              \n85              recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n86              if (recvResult == SOCKET_ERROR || recvResult == 0)\n87              {\n88                  break;\n89              }\n90              \n91              inputBuffer[recvResult] = '\\0';\n92              \n93              data = (float)atof(inputBuffer);\n94          }\n95          while (0);\n96          if (connectSocket != INVALID_SOCKET)\n97          {\n98              CLOSE_SOCKET(connectSocket);\n99          }\n100  #ifdef _WIN32\n101          if (wsaDataInit)\n102          {\n103              WSACleanup();\n104          }\n105  #endif\n106      }\n107      {\n108          \n109          int result = (int)(100.0 / data);\n110          printIntLine(result);\n111      }\n112  }\n113  \n114  #endif \n115  \n116  #ifndef OMITGOOD\n117  \n118  \n119  static void fooxx()\n120  {\n121      float data;\n122      \n123      data = 0.0F;\n124      \n125      data = 2.0F;\n126      {\n127          \n128          int result = (int)(100.0 / data);\n129          printIntLine(result);\n130      }\n131  }\n132  \n133  \n134  static void fooyy()\n135  {\n136      float data;\n137      \n138      data = 0.0F;\n139      {\n140  #ifdef _WIN32\n141          WSADATA wsaData;\n142          int wsaDataInit = 0;\n143  #endif\n144          int recvResult;\n145          struct sockaddr_in service;\n146          SOCKET connectSocket = INVALID_SOCKET;\n147          char inputBuffer[CHAR_ARRAY_SIZE];\n148          do\n149          {\n150  #ifdef _WIN32\n151              if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n152              {\n153                  break;\n154              }\n155              wsaDataInit = 1;\n156  #endif\n157              connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n158              if (connectSocket == INVALID_SOCKET)\n159              {\n160                  break;\n161              }\n162              memset(&service, 0, sizeof(service));\n163              service.sin_family = AF_INET;\n164              service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n165              service.sin_port = htons(TCP_PORT);\n166              if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n167              {\n168                  break;\n169              }\n170              \n171  \n172              \n173              recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n174              if (recvResult == SOCKET_ERROR || recvResult == 0)\n175              {\n176                  break;\n177              }\n178              \n179              inputBuffer[recvResult] = '\\0';\n180              \n181              data = (float)atof(inputBuffer);\n182          }\n183          while (0);\n184          if (connectSocket != INVALID_SOCKET)\n185          {\n186              CLOSE_SOCKET(connectSocket);\n187          }\n188  #ifdef _WIN32\n189          if (wsaDataInit)\n190          {\n191              WSACleanup();\n192          }\n193  #endif\n194      }\n195      \n196      if(fabs(data) > 0.000001)\n197      {\n198          int result = (int)(100.0 / data);\n199          printIntLine(result);\n200      }\n201      else\n202      {\n203          printLine(\"This would result in a divide by zero\");\n204      }\n205  }\n206  \n207  void CWE369_Divide_by_Zero__float_connect_socket_01_foo()\n208  {\n209      fooxx();\n210      fooyy();\n211  }\n212  \n213  #endif \n214  \n215  \n216  \n217  \n218  \n219  \n220  #ifdef INCLUDEMAIN\n221  \n222  int main(int argc, char * argv[])\n223  {\n224      \n225      srand( (unsigned)time(NULL) );\n226  #ifndef OMITGOOD\n227      printLine(\"Calling foo()...\");\n228      CWE369_Divide_by_Zero__float_connect_socket_01_foo();\n229      printLine(\"Finished foo()\");\n230  #endif \n231  #ifndef OMITBAD\n232      printLine(\"Calling hoo()...\");\n233      CWE369_Divide_by_Zero__float_connect_socket_01_hoo();\n234      printLine(\"Finished hoo()\");\n235  #endif \n236      return 0;\n237  }\n238  \n239  #endif\n240  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation: In the file CWE369_Divide_by_Zero__float_connect_socket_01.c, the value of data at line 50 is assigned with the literal 0.0F. This value is then used as the divisor in the expression (100.0 / data) at line 109, which can lead to a divide-by-zero bug.], [Trace: (Line 50, is_zero(data)), (Line 109, is_zero(data))]\n---------------END REPORT----------------",
        "all program size": 245,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}