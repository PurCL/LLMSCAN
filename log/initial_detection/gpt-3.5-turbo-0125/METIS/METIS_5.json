{
    "response": {
        "analyzed code": "1  void Compute2WayPartitionParams(ctrl_t *ctrl, graph_t *graph)\n2  {\n3    idx_t i, j, nvtxs, ncon, nbnd, mincut, istart, iend, tid, ted, me;\n4    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *pwgts;\n5    idx_t *where, *bndptr, *bndind, *id, *ed;\n6  \n7    nvtxs  = graph->nvtxs;\n8    ncon   = graph->ncon;\n9    xadj   = graph->xadj;\n10    vwgt   = graph->vwgt;\n11    adjncy = graph->adjncy;\n12    adjwgt = graph->adjwgt;\n13  \n14    where  = graph->where;\n15    id     = graph->id;\n16    ed     = graph->ed;\n17  \n18    pwgts  = iset(2*ncon, 0, graph->pwgts);\n19    bndptr = iset(nvtxs, -1, graph->bndptr);\n20    bndind = graph->bndind;\n21  \n22    /* Compute pwgts */\n23    if (ncon == 1) {\n24      for (i=0; i<nvtxs; i++) {\n25        ASSERT(where[i] >= 0 && where[i] <= 1);\n26        pwgts[where[i]] += vwgt[i];\n27      }\n28      ASSERT(pwgts[0]+pwgts[1] == graph->tvwgt[0]);\n29    }\n30    else {\n31      for (i=0; i<nvtxs; i++) {\n32        me = where[i];\n33        for (j=0; j<ncon; j++)\n34          pwgts[me*ncon+j] += vwgt[i*ncon+j];\n35      }\n36    }\n37  \n38  \n39    /* Compute the required info for refinement  */\n40    for (nbnd=0, mincut=0, i=0; i<nvtxs; i++) {\n41      istart = xadj[i];\n42      iend   = xadj[i+1];\n43  \n44      me = where[i];\n45      tid = ted = 0;\n46  \n47      for (j=istart; j<iend; j++) {\n48        if (me == where[adjncy[j]])\n49          tid += adjwgt[j];\n50        else\n51          ted += adjwgt[j];\n52      }\n53      id[i] = tid;\n54      ed[i] = ted;\n55    \n56      if (ted > 0 || istart == iend) {\n57        BNDInsert(nbnd, bndind, bndptr, i);\n58        mincut += ted;\n59      }\n60    }\n61  \n62    graph->mincut = mincut/2;\n63    graph->nbnd   = nbnd;\n64  \n65  }\n66  void GrowBisection(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n67           idx_t niparts)\n68  {\n69    idx_t i, j, k, nvtxs, drain, nleft, first, last, \n70          pwgts[2], oneminpwgt, onemaxpwgt, \n71          from, me, bestcut=0, icut, mincut, inbfs;\n72    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *where;\n73    idx_t *queue, *touched, *gain, *bestwhere;\n74  \n75    WCOREPUSH;\n76  \n77    nvtxs  = graph->nvtxs;\n78    xadj   = graph->xadj;\n79    vwgt   = graph->vwgt;\n80    adjncy = graph->adjncy;\n81    adjwgt = graph->adjwgt;\n82  \n83    Allocate2WayPartitionMemory(ctrl, graph);\n84    where = graph->where;\n85  \n86    bestwhere = iwspacemalloc(ctrl, nvtxs);\n87    queue     = iwspacemalloc(ctrl, nvtxs);\n88    touched   = iwspacemalloc(ctrl, nvtxs);\n89  \n90    onemaxpwgt = ctrl->ubfactors[0]*graph->tvwgt[0]*ntpwgts[1];\n91    oneminpwgt = (1.0/ctrl->ubfactors[0])*graph->tvwgt[0]*ntpwgts[1];\n92  \n93    for (inbfs=0; inbfs<niparts; inbfs++) {\n94      iset(nvtxs, 1, where);\n95  \n96      iset(nvtxs, 0, touched);\n97  \n98      pwgts[1] = graph->tvwgt[0];\n99      pwgts[0] = 0;\n100  \n101  \n102      queue[0] = irandInRange(nvtxs);\n103      touched[queue[0]] = 1;\n104      first = 0; \n105      last  = 1;\n106      nleft = nvtxs-1;\n107      drain = 0;\n108  \n109      /* Start the BFS from queue to get a partition */\n110      for (;;) {\n111        if (first == last) { /* Empty. Disconnected graph! */\n112          if (nleft == 0 || drain)\n113            break;\n114  \n115          k = irandInRange(nleft);\n116          for (i=0; i<nvtxs; i++) {\n117            if (touched[i] == 0) {\n118              if (k == 0)\n119                break;\n120              else\n121                k--;\n122            }\n123          }\n124  \n125          queue[0]   = i;\n126          touched[i] = 1;\n127          first      = 0; \n128          last       = 1;\n129          nleft--;\n130        }\n131  \n132        i = queue[first++];\n133        if (pwgts[0] > 0 && pwgts[1]-vwgt[i] < oneminpwgt) {\n134          drain = 1;\n135          continue;\n136        }\n137  \n138        where[i] = 0;\n139        INC_DEC(pwgts[0], pwgts[1], vwgt[i]);\n140        if (pwgts[1] <= onemaxpwgt)\n141          break;\n142  \n143        drain = 0;\n144        for (j=xadj[i]; j<xadj[i+1]; j++) {\n145          k = adjncy[j];\n146          if (touched[k] == 0) {\n147            queue[last++] = k;\n148            touched[k] = 1;\n149            nleft--;\n150          }\n151        }\n152      }\n153  \n154      /* Check to see if we hit any bad limiting cases */\n155      if (pwgts[1] == 0) \n156        where[irandInRange(nvtxs)] = 1;\n157      if (pwgts[0] == 0) \n158        where[irandInRange(nvtxs)] = 0;\n159  \n160      /*************************************************************\n161      * Do some partition refinement \n162      **************************************************************/\n163      Compute2WayPartitionParams(ctrl, graph);\n164      /*\n165      printf(\"IPART: %3\"PRIDX\" [%5\"PRIDX\" %5\"PRIDX\"] [%5\"PRIDX\" %5\"PRIDX\"] %5\"PRIDX\"\\n\", \n166          graph->nvtxs, pwgts[0], pwgts[1], graph->pwgts[0], graph->pwgts[1], graph->mincut); \n167      */\n168  \n169      Balance2Way(ctrl, graph, ntpwgts);\n170      /*\n171      printf(\"BPART: [%5\"PRIDX\" %5\"PRIDX\"] %5\"PRIDX\"\\n\", graph->pwgts[0],\n172          graph->pwgts[1], graph->mincut); \n173      */\n174  \n175      FM_2WayRefine(ctrl, graph, ntpwgts, ctrl->niter);\n176      /*\n177      printf(\"RPART: [%5\"PRIDX\" %5\"PRIDX\"] %5\"PRIDX\"\\n\", graph->pwgts[0], \n178          graph->pwgts[1], graph->mincut);\n179      */\n180  \n181      if (inbfs == 0 || bestcut > graph->mincut) {\n182        bestcut = graph->mincut;\n183        icopy(nvtxs, where, bestwhere);\n184        if (bestcut == 0)\n185          break;\n186      }\n187    }\n188  \n189    graph->mincut = bestcut;\n190    icopy(nvtxs, bestwhere, where);\n191  \n192    WCOREPOP;\n193  }\n194  void Init2WayPartition(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n195           idx_t niparts) \n196  {\n197    mdbglvl_et dbglvl;\n198  \n199    ASSERT(graph->tvwgt[0] >= 0);\n200  \n201    dbglvl = ctrl->dbglvl;\n202    IFSET(ctrl->dbglvl, METIS_DBG_REFINE, ctrl->dbglvl -= METIS_DBG_REFINE);\n203    IFSET(ctrl->dbglvl, METIS_DBG_MOVEINFO, ctrl->dbglvl -= METIS_DBG_MOVEINFO);\n204  \n205    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->InitPartTmr));\n206  \n207    switch (ctrl->iptype) {\n208      case METIS_IPTYPE_RANDOM:\n209        if (graph->ncon == 1)\n210          RandomBisection(ctrl, graph, ntpwgts, niparts);\n211        else\n212          McRandomBisection(ctrl, graph, ntpwgts, niparts);\n213        break;\n214  \n215      case METIS_IPTYPE_GROW:\n216        if (graph->nedges == 0)\n217          if (graph->ncon == 1)\n218            RandomBisection(ctrl, graph, ntpwgts, niparts);\n219          else\n220            McRandomBisection(ctrl, graph, ntpwgts, niparts);\n221        else\n222          if (graph->ncon == 1)\n223            GrowBisection(ctrl, graph, ntpwgts, niparts);\n224          else\n225            McGrowBisection(ctrl, graph, ntpwgts, niparts);\n226        break;\n227  \n228      default:\n229        gk_errexit(SIGERR, \"Unknown initial partition type: %d\\n\", ctrl->iptype);\n230    }\n231  \n232    IFSET(ctrl->dbglvl, METIS_DBG_IPART, printf(\"Initial Cut: %\"PRIDX\"\\n\", graph->mincut));\n233    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->InitPartTmr));\n234    ctrl->dbglvl = dbglvl;\n235  \n236  }\n237  idx_t MultilevelBisect(ctrl_t *ctrl, graph_t *graph, real_t *tpwgts)\n238  {\n239    idx_t i, niparts, bestobj=0, curobj=0, *bestwhere=NULL;\n240    graph_t *cgraph;\n241    real_t bestbal=0.0, curbal=0.0;\n242  \n243    Setup2WayBalMultipliers(ctrl, graph, tpwgts);\n244  \n245    WCOREPUSH;\n246  \n247    if (ctrl->ncuts > 1)\n248      bestwhere = iwspacemalloc(ctrl, graph->nvtxs);\n249  \n250    for (i=0; i<ctrl->ncuts; i++) {\n251      cgraph = CoarsenGraph(ctrl, graph);\n252  \n253      niparts = (cgraph->nvtxs <= ctrl->CoarsenTo ? SMALLNIPARTS : LARGENIPARTS);\n254      Init2WayPartition(ctrl, cgraph, tpwgts, niparts);\n255  \n256      Refine2Way(ctrl, graph, cgraph, tpwgts);\n257  \n258      curobj = graph->mincut;\n259      curbal = ComputeLoadImbalanceDiff(graph, 2, ctrl->pijbm, ctrl->ubfactors);\n260  \n261      if (i == 0  \n262          || (curbal <= 0.0005 && bestobj > curobj) \n263          || (bestbal > 0.0005 && curbal < bestbal)) {\n264        bestobj = curobj;\n265        bestbal = curbal;\n266        if (i < ctrl->ncuts-1)\n267          icopy(graph->nvtxs, graph->where, bestwhere);\n268      }\n269  \n270      if (bestobj == 0)\n271        break;\n272  \n273      if (i < ctrl->ncuts-1)\n274        FreeRData(graph);\n275    }\n276  \n277    if (bestobj != curobj) {\n278      icopy(graph->nvtxs, bestwhere, graph->where);\n279      Compute2WayPartitionParams(ctrl, graph);\n280    }\n281  \n282    WCOREPOP;\n283  \n284    return bestobj;\n285  }\n286  idx_t MlevelRecursiveBisection(ctrl_t *ctrl, graph_t *graph, idx_t nparts, \n287            idx_t *part, real_t *tpwgts, idx_t fpart)\n288  {\n289    idx_t i, j, nvtxs, ncon, objval;\n290    idx_t *label, *where;\n291    graph_t *lgraph, *rgraph;\n292    real_t wsum, *tpwgts2;\n293  \n294    if ((nvtxs = graph->nvtxs) == 0) {\n295      printf(\"\\t***Cannot bisect a graph with 0 vertices!\\n\"\n296             \"\\t***You are trying to partition a graph into too many parts!\\n\");\n297      return 0;\n298    }\n299  \n300    ncon = graph->ncon;\n301  \n302    /* determine the weights of the two partitions as a function of the weight of the\n303       target partition weights */\n304    WCOREPUSH;\n305    tpwgts2 = rwspacemalloc(ctrl, 2*ncon);\n306    for (i=0; i<ncon; i++) {\n307      tpwgts2[i]      = rsum((nparts>>1), tpwgts+i, ncon);\n308      tpwgts2[ncon+i] = 1.0 - tpwgts2[i];\n309    }\n310  \n311    /* perform the bisection */\n312    objval = MultilevelBisect(ctrl, graph, tpwgts2);\n313  \n314    WCOREPOP;\n315  \n316    label = graph->label;\n317    where = graph->where;\n318    for (i=0; i<nvtxs; i++)\n319      part[label[i]] = where[i] + fpart;\n320  \n321    if (nparts > 2) \n322      SplitGraphPart(ctrl, graph, &lgraph, &rgraph);\n323  \n324    /* Free the memory of the top level graph */\n325    FreeGraph(&graph);\n326  \n327    /* Scale the fractions in the tpwgts according to the true weight */\n328    for (i=0; i<ncon; i++) {\n329      wsum = rsum((nparts>>1), tpwgts+i, ncon);\n330      rscale((nparts>>1), 1.0/wsum, tpwgts+i, ncon);\n331      rscale(nparts-(nparts>>1), 1.0/(1.0-wsum), tpwgts+(nparts>>1)*ncon+i, ncon);\n332    }\n333  \n334    /* Do the recursive call */\n335    if (nparts > 3) {\n336      objval += MlevelRecursiveBisection(ctrl, lgraph, (nparts>>1), part, \n337                 tpwgts, fpart);\n338      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n339                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n340    }\n341    else if (nparts == 3) {\n342      FreeGraph(&lgraph);\n343      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n344                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n345    }\n346  \n347  \n348    return objval;\n349  }\n350  int METIS_PartGraphRecursive(idx_t *nvtxs, idx_t *ncon, idx_t *xadj, \n351            idx_t *adjncy, idx_t *vwgt, idx_t *vsize, idx_t *adjwgt, \n352            idx_t *nparts, real_t *tpwgts, real_t *ubvec, idx_t *options, \n353            idx_t *objval, idx_t *part)\n354  {\n355    int sigrval=0, renumber=0;\n356    graph_t *graph;\n357    ctrl_t *ctrl;\n358  \n359    /* set up malloc cleaning code and signal catchers */\n360    if (!gk_malloc_init()) \n361      return METIS_ERROR_MEMORY;\n362  \n363    gk_sigtrap();\n364  \n365    if ((sigrval = gk_sigcatch()) != 0) \n366      goto SIGTHROW;\n367  \n368    /* set up the run parameters */\n369    ctrl = SetupCtrl(METIS_OP_PMETIS, options, *ncon, *nparts, tpwgts, ubvec);\n370    if (!ctrl) {\n371      gk_siguntrap();\n372      return METIS_ERROR_INPUT;\n373    }\n374  \n375    /* if required, change the numbering to 0 */\n376    if (ctrl->numflag == 1) {\n377      Change2CNumbering(*nvtxs, xadj, adjncy);\n378      renumber = 1;\n379    }\n380  \n381    /* set up the graph */\n382    graph = SetupGraph(ctrl, *nvtxs, *ncon, xadj, adjncy, vwgt, vsize, adjwgt);\n383  \n384    /* allocate workspace memory */\n385    AllocateWorkSpace(ctrl, graph);\n386  \n387    /* start the partitioning */\n388    IFSET(ctrl->dbglvl, METIS_DBG_TIME, InitTimers(ctrl));\n389    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->TotalTmr));\n390  \n391    iset(*nvtxs, 0, part);\n392    *objval = (*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0));\n393  \n394    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->TotalTmr));\n395    IFSET(ctrl->dbglvl, METIS_DBG_TIME, PrintTimers(ctrl));\n396  \n397    /* clean up */\n398    FreeCtrl(&ctrl);\n399  \n400  SIGTHROW:\n401    /* if required, change the numbering back to 1 */\n402    if (renumber)\n403      Change2FNumbering(*nvtxs, xadj, adjncy, part);\n404  \n405    gk_siguntrap();\n406    gk_malloc_cleanup(0);\n407  \n408    return metis_rcode(sigrval);\n409  }\n410  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation: In the file provided, there is a potential divide-by-zero bug at line 62. The variable 'mincut' is divided by 2, which can lead to a divide-by-zero situation if 'mincut' is 0.], [Trace: (Line 60, is_zero(ted)), (Line 61, is_zero(mincut)), (Line 62, is_zero(mincut))]\n\n- Bug 2, [Explanation: In the file provided, there is a potential divide-by-zero bug at line 101. The condition 'pwgts[1] <= onemaxpwgt' can lead to a divide-by-zero situation if 'onemaxpwgt' is 0.], [Trace: (Line 90, is_zero(onemaxpwgt)), (Line 101, is_zero(onemaxpwgt))]\n\n- Bug 3, [Explanation: In the file provided, there is a potential divide-by-zero bug at line 133. The condition 'pwgts[1] > 0 && pwgts[1]-vwgt[i] < oneminpwgt' can lead to a divide-by-zero situation if 'pwgts[1]' is 0.], [Trace: (Line 90, is_zero(oneminpwgt)), (Line 133, is_zero(pwgts[1]))]\n\n- Bug 4, [Explanation: In the file provided, there is a potential divide-by-zero bug at line 155. The condition 'pwgts[1] == 0' can lead to a divide-by-zero situation if 'pwgts[1]' is 0.], [Trace: (Line 98, is_zero(pwgts[1])), (Line 155, is_zero(pwgts[1]))]\n\n- Bug 5, [Explanation: In the file provided, there is a potential divide-by-zero bug at line 157. The condition 'pwgts[0] == 0' can lead to a divide-by-zero situation if 'pwgts[0]' is 0.], [Trace: (Line 98, is_zero(pwgts[0])), (Line 157, is_zero(pwgts[0]))]\n---------------END REPORT----------------",
        "all program size": 414,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}