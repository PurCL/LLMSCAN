{
    "response": {
        "analyzed code": "1  void Compute2WayPartitionParams(ctrl_t *ctrl, graph_t *graph)\n2  {\n3    idx_t i, j, nvtxs, ncon, nbnd, mincut, istart, iend, tid, ted, me;\n4    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *pwgts;\n5    idx_t *where, *bndptr, *bndind, *id, *ed;\n6  \n7    nvtxs  = graph->nvtxs;\n8    ncon   = graph->ncon;\n9    xadj   = graph->xadj;\n10    vwgt   = graph->vwgt;\n11    adjncy = graph->adjncy;\n12    adjwgt = graph->adjwgt;\n13  \n14    where  = graph->where;\n15    id     = graph->id;\n16    ed     = graph->ed;\n17  \n18    pwgts  = iset(2*ncon, 0, graph->pwgts);\n19    bndptr = iset(nvtxs, -1, graph->bndptr);\n20    bndind = graph->bndind;\n21  \n22    /* Compute pwgts */\n23    if (ncon == 1) {\n24      for (i=0; i<nvtxs; i++) {\n25        ASSERT(where[i] >= 0 && where[i] <= 1);\n26        pwgts[where[i]] += vwgt[i];\n27      }\n28      ASSERT(pwgts[0]+pwgts[1] == graph->tvwgt[0]);\n29    }\n30    else {\n31      for (i=0; i<nvtxs; i++) {\n32        me = where[i];\n33        for (j=0; j<ncon; j++)\n34          pwgts[me*ncon+j] += vwgt[i*ncon+j];\n35      }\n36    }\n37  \n38  \n39    /* Compute the required info for refinement  */\n40    for (nbnd=0, mincut=0, i=0; i<nvtxs; i++) {\n41      istart = xadj[i];\n42      iend   = xadj[i+1];\n43  \n44      me = where[i];\n45      tid = ted = 0;\n46  \n47      for (j=istart; j<iend; j++) {\n48        if (me == where[adjncy[j]])\n49          tid += adjwgt[j];\n50        else\n51          ted += adjwgt[j];\n52      }\n53      id[i] = tid;\n54      ed[i] = ted;\n55    \n56      if (ted > 0 || istart == iend) {\n57        BNDInsert(nbnd, bndind, bndptr, i);\n58        mincut += ted;\n59      }\n60    }\n61  \n62    graph->mincut = mincut/2;\n63    graph->nbnd   = nbnd;\n64  \n65  }\n66  void RandomBisection(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n67           idx_t niparts)\n68  {\n69    idx_t i, ii, j, k, nvtxs, pwgts[2], zeromaxpwgt, from, me, \n70          bestcut=0, icut, mincut, inbfs;\n71    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *where;\n72    idx_t *perm, *bestwhere;\n73  \n74    WCOREPUSH;\n75  \n76    nvtxs  = graph->nvtxs;\n77    xadj   = graph->xadj;\n78    vwgt   = graph->vwgt;\n79    adjncy = graph->adjncy;\n80    adjwgt = graph->adjwgt;\n81  \n82    Allocate2WayPartitionMemory(ctrl, graph);\n83    where = graph->where;\n84  \n85    bestwhere = iwspacemalloc(ctrl, nvtxs);\n86    perm      = iwspacemalloc(ctrl, nvtxs);\n87  \n88    zeromaxpwgt = ctrl->ubfactors[0]*graph->tvwgt[0]*ntpwgts[0];\n89  \n90    for (inbfs=0; inbfs<niparts; inbfs++) {\n91      iset(nvtxs, 1, where);\n92  \n93      if (inbfs > 0) {\n94        irandArrayPermute(nvtxs, perm, nvtxs/2, 1);\n95        pwgts[1] = graph->tvwgt[0];\n96        pwgts[0] = 0;\n97  \n98        for (ii=0; ii<nvtxs; ii++) {\n99          i = perm[ii];\n100          if (pwgts[0]+vwgt[i] < zeromaxpwgt) {\n101            where[i] = 0;\n102            pwgts[0] += vwgt[i];\n103            pwgts[1] -= vwgt[i];\n104            if (pwgts[0] > zeromaxpwgt)\n105              break;\n106          }\n107        }\n108      }\n109  \n110      /* Do some partition refinement  */\n111      Compute2WayPartitionParams(ctrl, graph);\n112      /* printf(\"IPART: %3\"PRIDX\" [%5\"PRIDX\" %5\"PRIDX\"] [%5\"PRIDX\" %5\"PRIDX\"] %5\"PRIDX\"\\n\", graph->nvtxs, pwgts[0], pwgts[1], graph->pwgts[0], graph->pwgts[1], graph->mincut); */\n113  \n114      Balance2Way(ctrl, graph, ntpwgts);\n115      /* printf(\"BPART: [%5\"PRIDX\" %5\"PRIDX\"] %5\"PRIDX\"\\n\", graph->pwgts[0], graph->pwgts[1], graph->mincut); */\n116  \n117      FM_2WayRefine(ctrl, graph, ntpwgts, 4);\n118      /* printf(\"RPART: [%5\"PRIDX\" %5\"PRIDX\"] %5\"PRIDX\"\\n\", graph->pwgts[0], graph->pwgts[1], graph->mincut); */\n119  \n120      if (inbfs==0 || bestcut > graph->mincut) {\n121        bestcut = graph->mincut;\n122        icopy(nvtxs, where, bestwhere);\n123        if (bestcut == 0)\n124          break;\n125      }\n126    }\n127  \n128    graph->mincut = bestcut;\n129    icopy(nvtxs, bestwhere, where);\n130  \n131    WCOREPOP;\n132  }\n133  void Init2WayPartition(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n134           idx_t niparts) \n135  {\n136    mdbglvl_et dbglvl;\n137  \n138    ASSERT(graph->tvwgt[0] >= 0);\n139  \n140    dbglvl = ctrl->dbglvl;\n141    IFSET(ctrl->dbglvl, METIS_DBG_REFINE, ctrl->dbglvl -= METIS_DBG_REFINE);\n142    IFSET(ctrl->dbglvl, METIS_DBG_MOVEINFO, ctrl->dbglvl -= METIS_DBG_MOVEINFO);\n143  \n144    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->InitPartTmr));\n145  \n146    switch (ctrl->iptype) {\n147      case METIS_IPTYPE_RANDOM:\n148        if (graph->ncon == 1)\n149          RandomBisection(ctrl, graph, ntpwgts, niparts);\n150        else\n151          McRandomBisection(ctrl, graph, ntpwgts, niparts);\n152        break;\n153  \n154      case METIS_IPTYPE_GROW:\n155        if (graph->nedges == 0)\n156          if (graph->ncon == 1)\n157            RandomBisection(ctrl, graph, ntpwgts, niparts);\n158          else\n159            McRandomBisection(ctrl, graph, ntpwgts, niparts);\n160        else\n161          if (graph->ncon == 1)\n162            GrowBisection(ctrl, graph, ntpwgts, niparts);\n163          else\n164            McGrowBisection(ctrl, graph, ntpwgts, niparts);\n165        break;\n166  \n167      default:\n168        gk_errexit(SIGERR, \"Unknown initial partition type: %d\\n\", ctrl->iptype);\n169    }\n170  \n171    IFSET(ctrl->dbglvl, METIS_DBG_IPART, printf(\"Initial Cut: %\"PRIDX\"\\n\", graph->mincut));\n172    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->InitPartTmr));\n173    ctrl->dbglvl = dbglvl;\n174  \n175  }\n176  idx_t MultilevelBisect(ctrl_t *ctrl, graph_t *graph, real_t *tpwgts)\n177  {\n178    idx_t i, niparts, bestobj=0, curobj=0, *bestwhere=NULL;\n179    graph_t *cgraph;\n180    real_t bestbal=0.0, curbal=0.0;\n181  \n182    Setup2WayBalMultipliers(ctrl, graph, tpwgts);\n183  \n184    WCOREPUSH;\n185  \n186    if (ctrl->ncuts > 1)\n187      bestwhere = iwspacemalloc(ctrl, graph->nvtxs);\n188  \n189    for (i=0; i<ctrl->ncuts; i++) {\n190      cgraph = CoarsenGraph(ctrl, graph);\n191  \n192      niparts = (cgraph->nvtxs <= ctrl->CoarsenTo ? SMALLNIPARTS : LARGENIPARTS);\n193      Init2WayPartition(ctrl, cgraph, tpwgts, niparts);\n194  \n195      Refine2Way(ctrl, graph, cgraph, tpwgts);\n196  \n197      curobj = graph->mincut;\n198      curbal = ComputeLoadImbalanceDiff(graph, 2, ctrl->pijbm, ctrl->ubfactors);\n199  \n200      if (i == 0  \n201          || (curbal <= 0.0005 && bestobj > curobj) \n202          || (bestbal > 0.0005 && curbal < bestbal)) {\n203        bestobj = curobj;\n204        bestbal = curbal;\n205        if (i < ctrl->ncuts-1)\n206          icopy(graph->nvtxs, graph->where, bestwhere);\n207      }\n208  \n209      if (bestobj == 0)\n210        break;\n211  \n212      if (i < ctrl->ncuts-1)\n213        FreeRData(graph);\n214    }\n215  \n216    if (bestobj != curobj) {\n217      icopy(graph->nvtxs, bestwhere, graph->where);\n218      Compute2WayPartitionParams(ctrl, graph);\n219    }\n220  \n221    WCOREPOP;\n222  \n223    return bestobj;\n224  }\n225  idx_t MlevelRecursiveBisection(ctrl_t *ctrl, graph_t *graph, idx_t nparts, \n226            idx_t *part, real_t *tpwgts, idx_t fpart)\n227  {\n228    idx_t i, j, nvtxs, ncon, objval;\n229    idx_t *label, *where;\n230    graph_t *lgraph, *rgraph;\n231    real_t wsum, *tpwgts2;\n232  \n233    if ((nvtxs = graph->nvtxs) == 0) {\n234      printf(\"\\t***Cannot bisect a graph with 0 vertices!\\n\"\n235             \"\\t***You are trying to partition a graph into too many parts!\\n\");\n236      return 0;\n237    }\n238  \n239    ncon = graph->ncon;\n240  \n241    /* determine the weights of the two partitions as a function of the weight of the\n242       target partition weights */\n243    WCOREPUSH;\n244    tpwgts2 = rwspacemalloc(ctrl, 2*ncon);\n245    for (i=0; i<ncon; i++) {\n246      tpwgts2[i]      = rsum((nparts>>1), tpwgts+i, ncon);\n247      tpwgts2[ncon+i] = 1.0 - tpwgts2[i];\n248    }\n249  \n250    /* perform the bisection */\n251    objval = MultilevelBisect(ctrl, graph, tpwgts2);\n252  \n253    WCOREPOP;\n254  \n255    label = graph->label;\n256    where = graph->where;\n257    for (i=0; i<nvtxs; i++)\n258      part[label[i]] = where[i] + fpart;\n259  \n260    if (nparts > 2) \n261      SplitGraphPart(ctrl, graph, &lgraph, &rgraph);\n262  \n263    /* Free the memory of the top level graph */\n264    FreeGraph(&graph);\n265  \n266    /* Scale the fractions in the tpwgts according to the true weight */\n267    for (i=0; i<ncon; i++) {\n268      wsum = rsum((nparts>>1), tpwgts+i, ncon);\n269      rscale((nparts>>1), 1.0/wsum, tpwgts+i, ncon);\n270      rscale(nparts-(nparts>>1), 1.0/(1.0-wsum), tpwgts+(nparts>>1)*ncon+i, ncon);\n271    }\n272  \n273    /* Do the recursive call */\n274    if (nparts > 3) {\n275      objval += MlevelRecursiveBisection(ctrl, lgraph, (nparts>>1), part, \n276                 tpwgts, fpart);\n277      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n278                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n279    }\n280    else if (nparts == 3) {\n281      FreeGraph(&lgraph);\n282      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n283                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n284    }\n285  \n286  \n287    return objval;\n288  }\n289  int METIS_PartGraphRecursive(idx_t *nvtxs, idx_t *ncon, idx_t *xadj, \n290            idx_t *adjncy, idx_t *vwgt, idx_t *vsize, idx_t *adjwgt, \n291            idx_t *nparts, real_t *tpwgts, real_t *ubvec, idx_t *options, \n292            idx_t *objval, idx_t *part)\n293  {\n294    int sigrval=0, renumber=0;\n295    graph_t *graph;\n296    ctrl_t *ctrl;\n297  \n298    /* set up malloc cleaning code and signal catchers */\n299    if (!gk_malloc_init()) \n300      return METIS_ERROR_MEMORY;\n301  \n302    gk_sigtrap();\n303  \n304    if ((sigrval = gk_sigcatch()) != 0) \n305      goto SIGTHROW;\n306  \n307    /* set up the run parameters */\n308    ctrl = SetupCtrl(METIS_OP_PMETIS, options, *ncon, *nparts, tpwgts, ubvec);\n309    if (!ctrl) {\n310      gk_siguntrap();\n311      return METIS_ERROR_INPUT;\n312    }\n313  \n314    /* if required, change the numbering to 0 */\n315    if (ctrl->numflag == 1) {\n316      Change2CNumbering(*nvtxs, xadj, adjncy);\n317      renumber = 1;\n318    }\n319  \n320    /* set up the graph */\n321    graph = SetupGraph(ctrl, *nvtxs, *ncon, xadj, adjncy, vwgt, vsize, adjwgt);\n322  \n323    /* allocate workspace memory */\n324    AllocateWorkSpace(ctrl, graph);\n325  \n326    /* start the partitioning */\n327    IFSET(ctrl->dbglvl, METIS_DBG_TIME, InitTimers(ctrl));\n328    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->TotalTmr));\n329  \n330    iset(*nvtxs, 0, part);\n331    *objval = (*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0));\n332  \n333    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->TotalTmr));\n334    IFSET(ctrl->dbglvl, METIS_DBG_TIME, PrintTimers(ctrl));\n335  \n336    /* clean up */\n337    FreeCtrl(&ctrl);\n338  \n339  SIGTHROW:\n340    /* if required, change the numbering back to 1 */\n341    if (renumber)\n342      Change2FNumbering(*nvtxs, xadj, adjncy, part);\n343  \n344    gk_siguntrap();\n345    gk_malloc_cleanup(0);\n346  \n347    return metis_rcode(sigrval);\n348  }\n349  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation: In the file provided, the value of `mincut` at line 62 is assigned the result of `mincut/2`, which can lead to a divide-by-zero bug if `mincut` is zero.], [Trace: (Line 62, is_zero(mincut))]\n\n- Bug 2, [Explanation: In the file provided, the value of `pwgts[0]` at line 28 is compared with the sum of `pwgts[0]` and `pwgts[1]`, which can lead to a divide-by-zero bug if `pwgts[1]` is zero.], [Trace: (Line 28, is_zero(pwgts[1]))]\n\n- Bug 3, [Explanation: In the file provided, the value of `pwgts[0]` at line 104 is compared with `zeromaxpwgt`, which can lead to a divide-by-zero bug if `zeromaxpwgt` is zero.], [Trace: (Line 104, is_zero(zeromaxpwgt))]\n\n- Bug 4, [Explanation: In the file provided, the value of `pwgts[0]` at line 106 is compared with `zeromaxpwgt`, which can lead to a divide-by-zero bug if `zeromaxpwgt` is zero.], [Trace: (Line 106, is_zero(zeromaxpwgt))]\n\n- Bug 5, [Explanation: In the file provided, the value of `bestbal` at line 204 is compared with `curbal`, which can lead to a divide-by-zero bug if `curbal` is zero.], [Trace: (Line 204, is_zero(curbal))]\n\n- Bug 6, [Explanation: In the file provided, the value of `bestbal` at line 206 is compared with `curbal`, which can lead to a divide-by-zero bug if `curbal` is zero.], [Trace: (Line 206, is_zero(curbal))]\n\n- Bug 7, [Explanation: In the file provided, the value of `bestobj` at line 220 is assigned the value of `graph->mincut`, which can lead to a divide-by-zero bug if `graph->mincut` is zero.], [Trace: (Line 220, is_zero(graph->mincut))]\n\n- Bug 8, [Explanation: In the file provided, the value of `bestobj` at line 220 is compared with `curobj`, which can lead to a divide-by-zero bug if `curobj` is zero.], [Trace: (Line 220, is_zero(curobj))]\n\n- Bug 9, [Explanation: In the file provided, the value of `bestobj` at line 253 is assigned the value of `(*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0))`, which can lead to a divide-by-zero bug if the result of the function call is zero.], [Trace: (Line 253, is_zero(MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0)))]\n---------------END REPORT----------------",
        "all program size": 353,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}