{
    "response": {
        "analyzed code": "1  void Balance2Way(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts)\n2  {\n3    if (ComputeLoadImbalanceDiff(graph, 2, ctrl->pijbm, ctrl->ubfactors) <= 0) \n4      return;\n5  \n6    if (graph->ncon == 1) {\n7      /* return right away if the balance is OK */\n8      if (rabs(ntpwgts[0]*graph->tvwgt[0]-graph->pwgts[0]) < 3*graph->tvwgt[0]/graph->nvtxs)\n9        return;\n10  \n11      if (graph->nbnd > 0)\n12        Bnd2WayBalance(ctrl, graph, ntpwgts);\n13      else\n14        General2WayBalance(ctrl, graph, ntpwgts);\n15    }\n16    else {\n17      McGeneral2WayBalance(ctrl, graph, ntpwgts);\n18    }\n19  }\n20  void McGrowBisection(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n21           idx_t niparts)\n22  {\n23    idx_t i, j, k, nvtxs, ncon, from, bestcut=0, mincut, inbfs;\n24    idx_t *bestwhere, *where;\n25  \n26    WCOREPUSH;\n27  \n28    nvtxs = graph->nvtxs;\n29  \n30    Allocate2WayPartitionMemory(ctrl, graph);\n31    where = graph->where;\n32  \n33    bestwhere = iwspacemalloc(ctrl, nvtxs);\n34  \n35    for (inbfs=0; inbfs<2*niparts; inbfs++) {\n36      iset(nvtxs, 1, where);\n37      where[irandInRange(nvtxs)] = 0;\n38  \n39      Compute2WayPartitionParams(ctrl, graph);\n40  \n41      Balance2Way(ctrl, graph, ntpwgts);\n42      FM_2WayRefine(ctrl, graph, ntpwgts, ctrl->niter);\n43      Balance2Way(ctrl, graph, ntpwgts);\n44      FM_2WayRefine(ctrl, graph, ntpwgts, ctrl->niter);\n45  \n46      if (inbfs == 0 || bestcut >= graph->mincut) {\n47        bestcut = graph->mincut;\n48        icopy(nvtxs, where, bestwhere);\n49        if (bestcut == 0)\n50          break;\n51      }\n52    }\n53  \n54    graph->mincut = bestcut;\n55    icopy(nvtxs, bestwhere, where);\n56  \n57    WCOREPOP;\n58  }\n59  void Init2WayPartition(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n60           idx_t niparts) \n61  {\n62    mdbglvl_et dbglvl;\n63  \n64    ASSERT(graph->tvwgt[0] >= 0);\n65  \n66    dbglvl = ctrl->dbglvl;\n67    IFSET(ctrl->dbglvl, METIS_DBG_REFINE, ctrl->dbglvl -= METIS_DBG_REFINE);\n68    IFSET(ctrl->dbglvl, METIS_DBG_MOVEINFO, ctrl->dbglvl -= METIS_DBG_MOVEINFO);\n69  \n70    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->InitPartTmr));\n71  \n72    switch (ctrl->iptype) {\n73      case METIS_IPTYPE_RANDOM:\n74        if (graph->ncon == 1)\n75          RandomBisection(ctrl, graph, ntpwgts, niparts);\n76        else\n77          McRandomBisection(ctrl, graph, ntpwgts, niparts);\n78        break;\n79  \n80      case METIS_IPTYPE_GROW:\n81        if (graph->nedges == 0)\n82          if (graph->ncon == 1)\n83            RandomBisection(ctrl, graph, ntpwgts, niparts);\n84          else\n85            McRandomBisection(ctrl, graph, ntpwgts, niparts);\n86        else\n87          if (graph->ncon == 1)\n88            GrowBisection(ctrl, graph, ntpwgts, niparts);\n89          else\n90            McGrowBisection(ctrl, graph, ntpwgts, niparts);\n91        break;\n92  \n93      default:\n94        gk_errexit(SIGERR, \"Unknown initial partition type: %d\\n\", ctrl->iptype);\n95    }\n96  \n97    IFSET(ctrl->dbglvl, METIS_DBG_IPART, printf(\"Initial Cut: %\"PRIDX\"\\n\", graph->mincut));\n98    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->InitPartTmr));\n99    ctrl->dbglvl = dbglvl;\n100  \n101  }\n102  idx_t MultilevelBisect(ctrl_t *ctrl, graph_t *graph, real_t *tpwgts)\n103  {\n104    idx_t i, niparts, bestobj=0, curobj=0, *bestwhere=NULL;\n105    graph_t *cgraph;\n106    real_t bestbal=0.0, curbal=0.0;\n107  \n108    Setup2WayBalMultipliers(ctrl, graph, tpwgts);\n109  \n110    WCOREPUSH;\n111  \n112    if (ctrl->ncuts > 1)\n113      bestwhere = iwspacemalloc(ctrl, graph->nvtxs);\n114  \n115    for (i=0; i<ctrl->ncuts; i++) {\n116      cgraph = CoarsenGraph(ctrl, graph);\n117  \n118      niparts = (cgraph->nvtxs <= ctrl->CoarsenTo ? SMALLNIPARTS : LARGENIPARTS);\n119      Init2WayPartition(ctrl, cgraph, tpwgts, niparts);\n120  \n121      Refine2Way(ctrl, graph, cgraph, tpwgts);\n122  \n123      curobj = graph->mincut;\n124      curbal = ComputeLoadImbalanceDiff(graph, 2, ctrl->pijbm, ctrl->ubfactors);\n125  \n126      if (i == 0  \n127          || (curbal <= 0.0005 && bestobj > curobj) \n128          || (bestbal > 0.0005 && curbal < bestbal)) {\n129        bestobj = curobj;\n130        bestbal = curbal;\n131        if (i < ctrl->ncuts-1)\n132          icopy(graph->nvtxs, graph->where, bestwhere);\n133      }\n134  \n135      if (bestobj == 0)\n136        break;\n137  \n138      if (i < ctrl->ncuts-1)\n139        FreeRData(graph);\n140    }\n141  \n142    if (bestobj != curobj) {\n143      icopy(graph->nvtxs, bestwhere, graph->where);\n144      Compute2WayPartitionParams(ctrl, graph);\n145    }\n146  \n147    WCOREPOP;\n148  \n149    return bestobj;\n150  }\n151  idx_t MlevelRecursiveBisection(ctrl_t *ctrl, graph_t *graph, idx_t nparts, \n152            idx_t *part, real_t *tpwgts, idx_t fpart)\n153  {\n154    idx_t i, j, nvtxs, ncon, objval;\n155    idx_t *label, *where;\n156    graph_t *lgraph, *rgraph;\n157    real_t wsum, *tpwgts2;\n158  \n159    if ((nvtxs = graph->nvtxs) == 0) {\n160      printf(\"\\t***Cannot bisect a graph with 0 vertices!\\n\"\n161             \"\\t***You are trying to partition a graph into too many parts!\\n\");\n162      return 0;\n163    }\n164  \n165    ncon = graph->ncon;\n166  \n167    /* determine the weights of the two partitions as a function of the weight of the\n168       target partition weights */\n169    WCOREPUSH;\n170    tpwgts2 = rwspacemalloc(ctrl, 2*ncon);\n171    for (i=0; i<ncon; i++) {\n172      tpwgts2[i]      = rsum((nparts>>1), tpwgts+i, ncon);\n173      tpwgts2[ncon+i] = 1.0 - tpwgts2[i];\n174    }\n175  \n176    /* perform the bisection */\n177    objval = MultilevelBisect(ctrl, graph, tpwgts2);\n178  \n179    WCOREPOP;\n180  \n181    label = graph->label;\n182    where = graph->where;\n183    for (i=0; i<nvtxs; i++)\n184      part[label[i]] = where[i] + fpart;\n185  \n186    if (nparts > 2) \n187      SplitGraphPart(ctrl, graph, &lgraph, &rgraph);\n188  \n189    /* Free the memory of the top level graph */\n190    FreeGraph(&graph);\n191  \n192    /* Scale the fractions in the tpwgts according to the true weight */\n193    for (i=0; i<ncon; i++) {\n194      wsum = rsum((nparts>>1), tpwgts+i, ncon);\n195      rscale((nparts>>1), 1.0/wsum, tpwgts+i, ncon);\n196      rscale(nparts-(nparts>>1), 1.0/(1.0-wsum), tpwgts+(nparts>>1)*ncon+i, ncon);\n197    }\n198  \n199    /* Do the recursive call */\n200    if (nparts > 3) {\n201      objval += MlevelRecursiveBisection(ctrl, lgraph, (nparts>>1), part, \n202                 tpwgts, fpart);\n203      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n204                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n205    }\n206    else if (nparts == 3) {\n207      FreeGraph(&lgraph);\n208      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n209                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n210    }\n211  \n212  \n213    return objval;\n214  }\n215  int METIS_PartGraphRecursive(idx_t *nvtxs, idx_t *ncon, idx_t *xadj, \n216            idx_t *adjncy, idx_t *vwgt, idx_t *vsize, idx_t *adjwgt, \n217            idx_t *nparts, real_t *tpwgts, real_t *ubvec, idx_t *options, \n218            idx_t *objval, idx_t *part)\n219  {\n220    int sigrval=0, renumber=0;\n221    graph_t *graph;\n222    ctrl_t *ctrl;\n223  \n224    /* set up malloc cleaning code and signal catchers */\n225    if (!gk_malloc_init()) \n226      return METIS_ERROR_MEMORY;\n227  \n228    gk_sigtrap();\n229  \n230    if ((sigrval = gk_sigcatch()) != 0) \n231      goto SIGTHROW;\n232  \n233    /* set up the run parameters */\n234    ctrl = SetupCtrl(METIS_OP_PMETIS, options, *ncon, *nparts, tpwgts, ubvec);\n235    if (!ctrl) {\n236      gk_siguntrap();\n237      return METIS_ERROR_INPUT;\n238    }\n239  \n240    /* if required, change the numbering to 0 */\n241    if (ctrl->numflag == 1) {\n242      Change2CNumbering(*nvtxs, xadj, adjncy);\n243      renumber = 1;\n244    }\n245  \n246    /* set up the graph */\n247    graph = SetupGraph(ctrl, *nvtxs, *ncon, xadj, adjncy, vwgt, vsize, adjwgt);\n248  \n249    /* allocate workspace memory */\n250    AllocateWorkSpace(ctrl, graph);\n251  \n252    /* start the partitioning */\n253    IFSET(ctrl->dbglvl, METIS_DBG_TIME, InitTimers(ctrl));\n254    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->TotalTmr));\n255  \n256    iset(*nvtxs, 0, part);\n257    *objval = (*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0));\n258  \n259    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->TotalTmr));\n260    IFSET(ctrl->dbglvl, METIS_DBG_TIME, PrintTimers(ctrl));\n261  \n262    /* clean up */\n263    FreeCtrl(&ctrl);\n264  \n265  SIGTHROW:\n266    /* if required, change the numbering back to 1 */\n267    if (renumber)\n268      Change2FNumbering(*nvtxs, xadj, adjncy, part);\n269  \n270    gk_siguntrap();\n271    gk_malloc_cleanup(0);\n272  \n273    return metis_rcode(sigrval);\n274  }\n275  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation: In the file Example6.c, the value of token at line 3 is produced by external input, which can be 0. It is returned by the return statement at line 4 and propagated back to the caller function named fun2 at line 7. The assignment at line 7 makes data equal to 0, so the second operand of % operator at line 8 is 0. Hence, there is a divide-by-zero bug at line 8.], [Trace: (Line 3, is_zero(token)), (Line 4, is_zero(token)), (Line 7, is_zero(data)), (Line 8, is_zero(data))]\n---------------END REPORT----------------",
        "all program size": 279,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}