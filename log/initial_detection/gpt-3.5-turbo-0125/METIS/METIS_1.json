{
    "response": {
        "analyzed code": "1  void SetupGraph_tvwgt(graph_t *graph)\n2  {\n3    idx_t i;\n4  \n5    if (graph->tvwgt == NULL) \n6      graph->tvwgt  = imalloc(graph->ncon, \"SetupGraph_tvwgt: tvwgt\");\n7    if (graph->invtvwgt == NULL) \n8      graph->invtvwgt = rmalloc(graph->ncon, \"SetupGraph_tvwgt: invtvwgt\");\n9  \n10    for (i=0; i<graph->ncon; i++) {\n11      graph->tvwgt[i]    = isum(graph->nvtxs, graph->vwgt+i, graph->ncon);\n12      graph->invtvwgt[i] = 1.0/(graph->tvwgt[i] > 0 ? graph->tvwgt[i] : 1);\n13    }\n14  }\n15  void SplitGraphPart(ctrl_t *ctrl, graph_t *graph, graph_t **r_lgraph, \n16           graph_t **r_rgraph)\n17  {\n18    idx_t i, j, k, l, istart, iend, mypart, nvtxs, ncon, snvtxs[2], snedges[2];\n19    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *label, *where, *bndptr;\n20    idx_t *sxadj[2], *svwgt[2], *sadjncy[2], *sadjwgt[2], *slabel[2];\n21    idx_t *rename;\n22    idx_t *auxadjncy, *auxadjwgt;\n23    graph_t *lgraph, *rgraph;\n24  \n25    WCOREPUSH;\n26  \n27    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->SplitTmr));\n28  \n29    nvtxs   = graph->nvtxs;\n30    ncon    = graph->ncon;\n31    xadj    = graph->xadj;\n32    vwgt    = graph->vwgt;\n33    adjncy  = graph->adjncy;\n34    adjwgt  = graph->adjwgt;\n35    label   = graph->label;\n36    where   = graph->where;\n37    bndptr  = graph->bndptr;\n38  \n39    ASSERT(bndptr != NULL);\n40  \n41    rename = iwspacemalloc(ctrl, nvtxs);\n42    \n43    snvtxs[0] = snvtxs[1] = snedges[0] = snedges[1] = 0;\n44    for (i=0; i<nvtxs; i++) {\n45      k = where[i];\n46      rename[i] = snvtxs[k]++;\n47      snedges[k] += xadj[i+1]-xadj[i];\n48    }\n49  \n50    lgraph      = SetupSplitGraph(graph, snvtxs[0], snedges[0]);\n51    sxadj[0]    = lgraph->xadj;\n52    svwgt[0]    = lgraph->vwgt;\n53    sadjncy[0]  = lgraph->adjncy; \t\n54    sadjwgt[0]  = lgraph->adjwgt; \n55    slabel[0]   = lgraph->label;\n56  \n57    rgraph      = SetupSplitGraph(graph, snvtxs[1], snedges[1]);\n58    sxadj[1]    = rgraph->xadj;\n59    svwgt[1]    = rgraph->vwgt;\n60    sadjncy[1]  = rgraph->adjncy; \t\n61    sadjwgt[1]  = rgraph->adjwgt; \n62    slabel[1]   = rgraph->label;\n63  \n64    snvtxs[0] = snvtxs[1] = snedges[0] = snedges[1] = 0;\n65    sxadj[0][0] = sxadj[1][0] = 0;\n66    for (i=0; i<nvtxs; i++) {\n67      mypart = where[i];\n68  \n69      istart = xadj[i];\n70      iend = xadj[i+1];\n71      if (bndptr[i] == -1) { /* This is an interior vertex */\n72        auxadjncy = sadjncy[mypart] + snedges[mypart] - istart;\n73        auxadjwgt = sadjwgt[mypart] + snedges[mypart] - istart;\n74        for(j=istart; j<iend; j++) {\n75          auxadjncy[j] = adjncy[j];\n76          auxadjwgt[j] = adjwgt[j]; \n77        }\n78        snedges[mypart] += iend-istart;\n79      }\n80      else {\n81        auxadjncy = sadjncy[mypart];\n82        auxadjwgt = sadjwgt[mypart];\n83        l = snedges[mypart];\n84        for (j=istart; j<iend; j++) {\n85          k = adjncy[j];\n86          if (where[k] == mypart) {\n87            auxadjncy[l] = k;\n88            auxadjwgt[l++] = adjwgt[j]; \n89          }\n90        }\n91        snedges[mypart] = l;\n92      }\n93  \n94      /* copy vertex weights */\n95      for (k=0; k<ncon; k++)\n96        svwgt[mypart][snvtxs[mypart]*ncon+k] = vwgt[i*ncon+k];\n97  \n98      slabel[mypart][snvtxs[mypart]]   = label[i];\n99      sxadj[mypart][++snvtxs[mypart]]  = snedges[mypart];\n100    }\n101  \n102    for (mypart=0; mypart<2; mypart++) {\n103      iend = sxadj[mypart][snvtxs[mypart]];\n104      auxadjncy = sadjncy[mypart];\n105      for (i=0; i<iend; i++) \n106        auxadjncy[i] = rename[auxadjncy[i]];\n107    }\n108  \n109    lgraph->nedges = snedges[0];\n110    rgraph->nedges = snedges[1];\n111  \n112    SetupGraph_tvwgt(lgraph);\n113    SetupGraph_tvwgt(rgraph);\n114  \n115    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->SplitTmr));\n116  \n117    *r_lgraph = lgraph;\n118    *r_rgraph = rgraph;\n119  \n120    WCOREPOP;\n121  }\n122  idx_t MlevelRecursiveBisection(ctrl_t *ctrl, graph_t *graph, idx_t nparts, \n123            idx_t *part, real_t *tpwgts, idx_t fpart)\n124  {\n125    idx_t i, j, nvtxs, ncon, objval;\n126    idx_t *label, *where;\n127    graph_t *lgraph, *rgraph;\n128    real_t wsum, *tpwgts2;\n129  \n130    if ((nvtxs = graph->nvtxs) == 0) {\n131      printf(\"\\t***Cannot bisect a graph with 0 vertices!\\n\"\n132             \"\\t***You are trying to partition a graph into too many parts!\\n\");\n133      return 0;\n134    }\n135  \n136    ncon = graph->ncon;\n137  \n138    /* determine the weights of the two partitions as a function of the weight of the\n139       target partition weights */\n140    WCOREPUSH;\n141    tpwgts2 = rwspacemalloc(ctrl, 2*ncon);\n142    for (i=0; i<ncon; i++) {\n143      tpwgts2[i]      = rsum((nparts>>1), tpwgts+i, ncon);\n144      tpwgts2[ncon+i] = 1.0 - tpwgts2[i];\n145    }\n146  \n147    /* perform the bisection */\n148    objval = MultilevelBisect(ctrl, graph, tpwgts2);\n149  \n150    WCOREPOP;\n151  \n152    label = graph->label;\n153    where = graph->where;\n154    for (i=0; i<nvtxs; i++)\n155      part[label[i]] = where[i] + fpart;\n156  \n157    if (nparts > 2) \n158      SplitGraphPart(ctrl, graph, &lgraph, &rgraph);\n159  \n160    /* Free the memory of the top level graph */\n161    FreeGraph(&graph);\n162  \n163    /* Scale the fractions in the tpwgts according to the true weight */\n164    for (i=0; i<ncon; i++) {\n165      wsum = rsum((nparts>>1), tpwgts+i, ncon);\n166      rscale((nparts>>1), 1.0/wsum, tpwgts+i, ncon);\n167      rscale(nparts-(nparts>>1), 1.0/(1.0-wsum), tpwgts+(nparts>>1)*ncon+i, ncon);\n168    }\n169  \n170    /* Do the recursive call */\n171    if (nparts > 3) {\n172      objval += MlevelRecursiveBisection(ctrl, lgraph, (nparts>>1), part, \n173                 tpwgts, fpart);\n174      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n175                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n176    }\n177    else if (nparts == 3) {\n178      FreeGraph(&lgraph);\n179      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n180                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n181    }\n182  \n183  \n184    return objval;\n185  }\n186  int METIS_PartGraphRecursive(idx_t *nvtxs, idx_t *ncon, idx_t *xadj, \n187            idx_t *adjncy, idx_t *vwgt, idx_t *vsize, idx_t *adjwgt, \n188            idx_t *nparts, real_t *tpwgts, real_t *ubvec, idx_t *options, \n189            idx_t *objval, idx_t *part)\n190  {\n191    int sigrval=0, renumber=0;\n192    graph_t *graph;\n193    ctrl_t *ctrl;\n194  \n195    /* set up malloc cleaning code and signal catchers */\n196    if (!gk_malloc_init()) \n197      return METIS_ERROR_MEMORY;\n198  \n199    gk_sigtrap();\n200  \n201    if ((sigrval = gk_sigcatch()) != 0) \n202      goto SIGTHROW;\n203  \n204    /* set up the run parameters */\n205    ctrl = SetupCtrl(METIS_OP_PMETIS, options, *ncon, *nparts, tpwgts, ubvec);\n206    if (!ctrl) {\n207      gk_siguntrap();\n208      return METIS_ERROR_INPUT;\n209    }\n210  \n211    /* if required, change the numbering to 0 */\n212    if (ctrl->numflag == 1) {\n213      Change2CNumbering(*nvtxs, xadj, adjncy);\n214      renumber = 1;\n215    }\n216  \n217    /* set up the graph */\n218    graph = SetupGraph(ctrl, *nvtxs, *ncon, xadj, adjncy, vwgt, vsize, adjwgt);\n219  \n220    /* allocate workspace memory */\n221    AllocateWorkSpace(ctrl, graph);\n222  \n223    /* start the partitioning */\n224    IFSET(ctrl->dbglvl, METIS_DBG_TIME, InitTimers(ctrl));\n225    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->TotalTmr));\n226  \n227    iset(*nvtxs, 0, part);\n228    *objval = (*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0));\n229  \n230    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->TotalTmr));\n231    IFSET(ctrl->dbglvl, METIS_DBG_TIME, PrintTimers(ctrl));\n232  \n233    /* clean up */\n234    FreeCtrl(&ctrl);\n235  \n236  SIGTHROW:\n237    /* if required, change the numbering back to 1 */\n238    if (renumber)\n239      Change2FNumbering(*nvtxs, xadj, adjncy, part);\n240  \n241    gk_siguntrap();\n242    gk_malloc_cleanup(0);\n243  \n244    return metis_rcode(sigrval);\n245  }\n246  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation, In the file provided, the value of graph->tvwgt[i] at line 12 can be zero due to the conditional assignment 1.0/(graph->tvwgt[i] > 0 ? graph->tvwgt[i] : 1) at line 12. This zero value can be propagated to the divisor of the % operator at line 13.], [Trace: (Line 12, is_zero(graph->tvwgt[i])), (Line 13, is_zero(graph->tvwgt[i]))]\n---------------END REPORT----------------",
        "all program size": 250,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}