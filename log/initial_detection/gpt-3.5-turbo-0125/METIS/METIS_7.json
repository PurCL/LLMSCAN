{
    "response": {
        "analyzed code": "1  void Compute2WayPartitionParams(ctrl_t *ctrl, graph_t *graph)\n2  {\n3    idx_t i, j, nvtxs, ncon, nbnd, mincut, istart, iend, tid, ted, me;\n4    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *pwgts;\n5    idx_t *where, *bndptr, *bndind, *id, *ed;\n6  \n7    nvtxs  = graph->nvtxs;\n8    ncon   = graph->ncon;\n9    xadj   = graph->xadj;\n10    vwgt   = graph->vwgt;\n11    adjncy = graph->adjncy;\n12    adjwgt = graph->adjwgt;\n13  \n14    where  = graph->where;\n15    id     = graph->id;\n16    ed     = graph->ed;\n17  \n18    pwgts  = iset(2*ncon, 0, graph->pwgts);\n19    bndptr = iset(nvtxs, -1, graph->bndptr);\n20    bndind = graph->bndind;\n21  \n22    /* Compute pwgts */\n23    if (ncon == 1) {\n24      for (i=0; i<nvtxs; i++) {\n25        ASSERT(where[i] >= 0 && where[i] <= 1);\n26        pwgts[where[i]] += vwgt[i];\n27      }\n28      ASSERT(pwgts[0]+pwgts[1] == graph->tvwgt[0]);\n29    }\n30    else {\n31      for (i=0; i<nvtxs; i++) {\n32        me = where[i];\n33        for (j=0; j<ncon; j++)\n34          pwgts[me*ncon+j] += vwgt[i*ncon+j];\n35      }\n36    }\n37  \n38  \n39    /* Compute the required info for refinement  */\n40    for (nbnd=0, mincut=0, i=0; i<nvtxs; i++) {\n41      istart = xadj[i];\n42      iend   = xadj[i+1];\n43  \n44      me = where[i];\n45      tid = ted = 0;\n46  \n47      for (j=istart; j<iend; j++) {\n48        if (me == where[adjncy[j]])\n49          tid += adjwgt[j];\n50        else\n51          ted += adjwgt[j];\n52      }\n53      id[i] = tid;\n54      ed[i] = ted;\n55    \n56      if (ted > 0 || istart == iend) {\n57        BNDInsert(nbnd, bndind, bndptr, i);\n58        mincut += ted;\n59      }\n60    }\n61  \n62    graph->mincut = mincut/2;\n63    graph->nbnd   = nbnd;\n64  \n65  }\n66  void Refine2Way(ctrl_t *ctrl, graph_t *orggraph, graph_t *graph, real_t *tpwgts)\n67  {\n68  \n69    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->UncoarsenTmr));\n70  \n71    /* Compute the parameters of the coarsest graph */\n72    Compute2WayPartitionParams(ctrl, graph);\n73  \n74    for (;;) {\n75      ASSERT(CheckBnd(graph));\n76  \n77      IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->RefTmr));\n78  \n79      Balance2Way(ctrl, graph, tpwgts);\n80  \n81      FM_2WayRefine(ctrl, graph, tpwgts, ctrl->niter); \n82  \n83      IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->RefTmr));\n84  \n85      if (graph == orggraph)\n86        break;\n87  \n88      graph = graph->finer;\n89      graph_ReadFromDisk(ctrl, graph);\n90  \n91      IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->ProjectTmr));\n92      Project2WayPartition(ctrl, graph);\n93      IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->ProjectTmr));\n94    }\n95  \n96    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->UncoarsenTmr));\n97  }\n98  idx_t MultilevelBisect(ctrl_t *ctrl, graph_t *graph, real_t *tpwgts)\n99  {\n100    idx_t i, niparts, bestobj=0, curobj=0, *bestwhere=NULL;\n101    graph_t *cgraph;\n102    real_t bestbal=0.0, curbal=0.0;\n103  \n104    Setup2WayBalMultipliers(ctrl, graph, tpwgts);\n105  \n106    WCOREPUSH;\n107  \n108    if (ctrl->ncuts > 1)\n109      bestwhere = iwspacemalloc(ctrl, graph->nvtxs);\n110  \n111    for (i=0; i<ctrl->ncuts; i++) {\n112      cgraph = CoarsenGraph(ctrl, graph);\n113  \n114      niparts = (cgraph->nvtxs <= ctrl->CoarsenTo ? SMALLNIPARTS : LARGENIPARTS);\n115      Init2WayPartition(ctrl, cgraph, tpwgts, niparts);\n116  \n117      Refine2Way(ctrl, graph, cgraph, tpwgts);\n118  \n119      curobj = graph->mincut;\n120      curbal = ComputeLoadImbalanceDiff(graph, 2, ctrl->pijbm, ctrl->ubfactors);\n121  \n122      if (i == 0  \n123          || (curbal <= 0.0005 && bestobj > curobj) \n124          || (bestbal > 0.0005 && curbal < bestbal)) {\n125        bestobj = curobj;\n126        bestbal = curbal;\n127        if (i < ctrl->ncuts-1)\n128          icopy(graph->nvtxs, graph->where, bestwhere);\n129      }\n130  \n131      if (bestobj == 0)\n132        break;\n133  \n134      if (i < ctrl->ncuts-1)\n135        FreeRData(graph);\n136    }\n137  \n138    if (bestobj != curobj) {\n139      icopy(graph->nvtxs, bestwhere, graph->where);\n140      Compute2WayPartitionParams(ctrl, graph);\n141    }\n142  \n143    WCOREPOP;\n144  \n145    return bestobj;\n146  }\n147  idx_t MlevelRecursiveBisection(ctrl_t *ctrl, graph_t *graph, idx_t nparts, \n148            idx_t *part, real_t *tpwgts, idx_t fpart)\n149  {\n150    idx_t i, j, nvtxs, ncon, objval;\n151    idx_t *label, *where;\n152    graph_t *lgraph, *rgraph;\n153    real_t wsum, *tpwgts2;\n154  \n155    if ((nvtxs = graph->nvtxs) == 0) {\n156      printf(\"\\t***Cannot bisect a graph with 0 vertices!\\n\"\n157             \"\\t***You are trying to partition a graph into too many parts!\\n\");\n158      return 0;\n159    }\n160  \n161    ncon = graph->ncon;\n162  \n163    /* determine the weights of the two partitions as a function of the weight of the\n164       target partition weights */\n165    WCOREPUSH;\n166    tpwgts2 = rwspacemalloc(ctrl, 2*ncon);\n167    for (i=0; i<ncon; i++) {\n168      tpwgts2[i]      = rsum((nparts>>1), tpwgts+i, ncon);\n169      tpwgts2[ncon+i] = 1.0 - tpwgts2[i];\n170    }\n171  \n172    /* perform the bisection */\n173    objval = MultilevelBisect(ctrl, graph, tpwgts2);\n174  \n175    WCOREPOP;\n176  \n177    label = graph->label;\n178    where = graph->where;\n179    for (i=0; i<nvtxs; i++)\n180      part[label[i]] = where[i] + fpart;\n181  \n182    if (nparts > 2) \n183      SplitGraphPart(ctrl, graph, &lgraph, &rgraph);\n184  \n185    /* Free the memory of the top level graph */\n186    FreeGraph(&graph);\n187  \n188    /* Scale the fractions in the tpwgts according to the true weight */\n189    for (i=0; i<ncon; i++) {\n190      wsum = rsum((nparts>>1), tpwgts+i, ncon);\n191      rscale((nparts>>1), 1.0/wsum, tpwgts+i, ncon);\n192      rscale(nparts-(nparts>>1), 1.0/(1.0-wsum), tpwgts+(nparts>>1)*ncon+i, ncon);\n193    }\n194  \n195    /* Do the recursive call */\n196    if (nparts > 3) {\n197      objval += MlevelRecursiveBisection(ctrl, lgraph, (nparts>>1), part, \n198                 tpwgts, fpart);\n199      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n200                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n201    }\n202    else if (nparts == 3) {\n203      FreeGraph(&lgraph);\n204      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n205                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n206    }\n207  \n208  \n209    return objval;\n210  }\n211  int METIS_PartGraphRecursive(idx_t *nvtxs, idx_t *ncon, idx_t *xadj, \n212            idx_t *adjncy, idx_t *vwgt, idx_t *vsize, idx_t *adjwgt, \n213            idx_t *nparts, real_t *tpwgts, real_t *ubvec, idx_t *options, \n214            idx_t *objval, idx_t *part)\n215  {\n216    int sigrval=0, renumber=0;\n217    graph_t *graph;\n218    ctrl_t *ctrl;\n219  \n220    /* set up malloc cleaning code and signal catchers */\n221    if (!gk_malloc_init()) \n222      return METIS_ERROR_MEMORY;\n223  \n224    gk_sigtrap();\n225  \n226    if ((sigrval = gk_sigcatch()) != 0) \n227      goto SIGTHROW;\n228  \n229    /* set up the run parameters */\n230    ctrl = SetupCtrl(METIS_OP_PMETIS, options, *ncon, *nparts, tpwgts, ubvec);\n231    if (!ctrl) {\n232      gk_siguntrap();\n233      return METIS_ERROR_INPUT;\n234    }\n235  \n236    /* if required, change the numbering to 0 */\n237    if (ctrl->numflag == 1) {\n238      Change2CNumbering(*nvtxs, xadj, adjncy);\n239      renumber = 1;\n240    }\n241  \n242    /* set up the graph */\n243    graph = SetupGraph(ctrl, *nvtxs, *ncon, xadj, adjncy, vwgt, vsize, adjwgt);\n244  \n245    /* allocate workspace memory */\n246    AllocateWorkSpace(ctrl, graph);\n247  \n248    /* start the partitioning */\n249    IFSET(ctrl->dbglvl, METIS_DBG_TIME, InitTimers(ctrl));\n250    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->TotalTmr));\n251  \n252    iset(*nvtxs, 0, part);\n253    *objval = (*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0));\n254  \n255    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->TotalTmr));\n256    IFSET(ctrl->dbglvl, METIS_DBG_TIME, PrintTimers(ctrl));\n257  \n258    /* clean up */\n259    FreeCtrl(&ctrl);\n260  \n261  SIGTHROW:\n262    /* if required, change the numbering back to 1 */\n263    if (renumber)\n264      Change2FNumbering(*nvtxs, xadj, adjncy, part);\n265  \n266    gk_siguntrap();\n267    gk_malloc_cleanup(0);\n268  \n269    return metis_rcode(sigrval);\n270  }\n271  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation: In the file provided, the value of mincut at line 62 is computed by dividing mincut by 2. However, the value of mincut is not checked for being zero before the division operation, which can lead to a divide-by-zero bug.], [Trace: (Line 62, is_zero(mincut))]\n\n---------------END REPORT----------------",
        "all program size": 275,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}