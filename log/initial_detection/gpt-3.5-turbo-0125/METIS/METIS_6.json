{
    "response": {
        "analyzed code": "1  void Compute2WayPartitionParams(ctrl_t *ctrl, graph_t *graph)\n2  {\n3    idx_t i, j, nvtxs, ncon, nbnd, mincut, istart, iend, tid, ted, me;\n4    idx_t *xadj, *vwgt, *adjncy, *adjwgt, *pwgts;\n5    idx_t *where, *bndptr, *bndind, *id, *ed;\n6  \n7    nvtxs  = graph->nvtxs;\n8    ncon   = graph->ncon;\n9    xadj   = graph->xadj;\n10    vwgt   = graph->vwgt;\n11    adjncy = graph->adjncy;\n12    adjwgt = graph->adjwgt;\n13  \n14    where  = graph->where;\n15    id     = graph->id;\n16    ed     = graph->ed;\n17  \n18    pwgts  = iset(2*ncon, 0, graph->pwgts);\n19    bndptr = iset(nvtxs, -1, graph->bndptr);\n20    bndind = graph->bndind;\n21  \n22    /* Compute pwgts */\n23    if (ncon == 1) {\n24      for (i=0; i<nvtxs; i++) {\n25        ASSERT(where[i] >= 0 && where[i] <= 1);\n26        pwgts[where[i]] += vwgt[i];\n27      }\n28      ASSERT(pwgts[0]+pwgts[1] == graph->tvwgt[0]);\n29    }\n30    else {\n31      for (i=0; i<nvtxs; i++) {\n32        me = where[i];\n33        for (j=0; j<ncon; j++)\n34          pwgts[me*ncon+j] += vwgt[i*ncon+j];\n35      }\n36    }\n37  \n38  \n39    /* Compute the required info for refinement  */\n40    for (nbnd=0, mincut=0, i=0; i<nvtxs; i++) {\n41      istart = xadj[i];\n42      iend   = xadj[i+1];\n43  \n44      me = where[i];\n45      tid = ted = 0;\n46  \n47      for (j=istart; j<iend; j++) {\n48        if (me == where[adjncy[j]])\n49          tid += adjwgt[j];\n50        else\n51          ted += adjwgt[j];\n52      }\n53      id[i] = tid;\n54      ed[i] = ted;\n55    \n56      if (ted > 0 || istart == iend) {\n57        BNDInsert(nbnd, bndind, bndptr, i);\n58        mincut += ted;\n59      }\n60    }\n61  \n62    graph->mincut = mincut/2;\n63    graph->nbnd   = nbnd;\n64  \n65  }\n66  void McRandomBisection(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n67           idx_t niparts)\n68  {\n69    idx_t i, ii, j, k, nvtxs, ncon, from, bestcut=0, mincut, inbfs, qnum;\n70    idx_t *bestwhere, *where, *perm, *counts;\n71    idx_t *vwgt;\n72  \n73    WCOREPUSH;\n74  \n75    nvtxs = graph->nvtxs;\n76    ncon  = graph->ncon;\n77    vwgt  = graph->vwgt;\n78  \n79    Allocate2WayPartitionMemory(ctrl, graph);\n80    where = graph->where;\n81  \n82    bestwhere = iwspacemalloc(ctrl, nvtxs);\n83    perm      = iwspacemalloc(ctrl, nvtxs);\n84    counts    = iwspacemalloc(ctrl, ncon);\n85  \n86    for (inbfs=0; inbfs<2*niparts; inbfs++) {\n87      irandArrayPermute(nvtxs, perm, nvtxs/2, 1);\n88      iset(ncon, 0, counts);\n89  \n90      /* partition by splitting the queues randomly */\n91      for (ii=0; ii<nvtxs; ii++) {\n92        i        = perm[ii];\n93        qnum     = iargmax(ncon, vwgt+i*ncon,1);\n94        where[i] = (counts[qnum]++)%2;\n95      }\n96  \n97      Compute2WayPartitionParams(ctrl, graph);\n98  \n99      FM_2WayRefine(ctrl, graph, ntpwgts, ctrl->niter);\n100      Balance2Way(ctrl, graph, ntpwgts);\n101      FM_2WayRefine(ctrl, graph, ntpwgts, ctrl->niter);\n102      Balance2Way(ctrl, graph, ntpwgts);\n103      FM_2WayRefine(ctrl, graph, ntpwgts, ctrl->niter);\n104  \n105      if (inbfs == 0 || bestcut >= graph->mincut) {\n106        bestcut = graph->mincut;\n107        icopy(nvtxs, where, bestwhere);\n108        if (bestcut == 0)\n109          break;\n110      }\n111    }\n112  \n113    graph->mincut = bestcut;\n114    icopy(nvtxs, bestwhere, where);\n115  \n116    WCOREPOP;\n117  }\n118  void Init2WayPartition(ctrl_t *ctrl, graph_t *graph, real_t *ntpwgts, \n119           idx_t niparts) \n120  {\n121    mdbglvl_et dbglvl;\n122  \n123    ASSERT(graph->tvwgt[0] >= 0);\n124  \n125    dbglvl = ctrl->dbglvl;\n126    IFSET(ctrl->dbglvl, METIS_DBG_REFINE, ctrl->dbglvl -= METIS_DBG_REFINE);\n127    IFSET(ctrl->dbglvl, METIS_DBG_MOVEINFO, ctrl->dbglvl -= METIS_DBG_MOVEINFO);\n128  \n129    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->InitPartTmr));\n130  \n131    switch (ctrl->iptype) {\n132      case METIS_IPTYPE_RANDOM:\n133        if (graph->ncon == 1)\n134          RandomBisection(ctrl, graph, ntpwgts, niparts);\n135        else\n136          McRandomBisection(ctrl, graph, ntpwgts, niparts);\n137        break;\n138  \n139      case METIS_IPTYPE_GROW:\n140        if (graph->nedges == 0)\n141          if (graph->ncon == 1)\n142            RandomBisection(ctrl, graph, ntpwgts, niparts);\n143          else\n144            McRandomBisection(ctrl, graph, ntpwgts, niparts);\n145        else\n146          if (graph->ncon == 1)\n147            GrowBisection(ctrl, graph, ntpwgts, niparts);\n148          else\n149            McGrowBisection(ctrl, graph, ntpwgts, niparts);\n150        break;\n151  \n152      default:\n153        gk_errexit(SIGERR, \"Unknown initial partition type: %d\\n\", ctrl->iptype);\n154    }\n155  \n156    IFSET(ctrl->dbglvl, METIS_DBG_IPART, printf(\"Initial Cut: %\"PRIDX\"\\n\", graph->mincut));\n157    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->InitPartTmr));\n158    ctrl->dbglvl = dbglvl;\n159  \n160  }\n161  idx_t MultilevelBisect(ctrl_t *ctrl, graph_t *graph, real_t *tpwgts)\n162  {\n163    idx_t i, niparts, bestobj=0, curobj=0, *bestwhere=NULL;\n164    graph_t *cgraph;\n165    real_t bestbal=0.0, curbal=0.0;\n166  \n167    Setup2WayBalMultipliers(ctrl, graph, tpwgts);\n168  \n169    WCOREPUSH;\n170  \n171    if (ctrl->ncuts > 1)\n172      bestwhere = iwspacemalloc(ctrl, graph->nvtxs);\n173  \n174    for (i=0; i<ctrl->ncuts; i++) {\n175      cgraph = CoarsenGraph(ctrl, graph);\n176  \n177      niparts = (cgraph->nvtxs <= ctrl->CoarsenTo ? SMALLNIPARTS : LARGENIPARTS);\n178      Init2WayPartition(ctrl, cgraph, tpwgts, niparts);\n179  \n180      Refine2Way(ctrl, graph, cgraph, tpwgts);\n181  \n182      curobj = graph->mincut;\n183      curbal = ComputeLoadImbalanceDiff(graph, 2, ctrl->pijbm, ctrl->ubfactors);\n184  \n185      if (i == 0  \n186          || (curbal <= 0.0005 && bestobj > curobj) \n187          || (bestbal > 0.0005 && curbal < bestbal)) {\n188        bestobj = curobj;\n189        bestbal = curbal;\n190        if (i < ctrl->ncuts-1)\n191          icopy(graph->nvtxs, graph->where, bestwhere);\n192      }\n193  \n194      if (bestobj == 0)\n195        break;\n196  \n197      if (i < ctrl->ncuts-1)\n198        FreeRData(graph);\n199    }\n200  \n201    if (bestobj != curobj) {\n202      icopy(graph->nvtxs, bestwhere, graph->where);\n203      Compute2WayPartitionParams(ctrl, graph);\n204    }\n205  \n206    WCOREPOP;\n207  \n208    return bestobj;\n209  }\n210  idx_t MlevelRecursiveBisection(ctrl_t *ctrl, graph_t *graph, idx_t nparts, \n211            idx_t *part, real_t *tpwgts, idx_t fpart)\n212  {\n213    idx_t i, j, nvtxs, ncon, objval;\n214    idx_t *label, *where;\n215    graph_t *lgraph, *rgraph;\n216    real_t wsum, *tpwgts2;\n217  \n218    if ((nvtxs = graph->nvtxs) == 0) {\n219      printf(\"\\t***Cannot bisect a graph with 0 vertices!\\n\"\n220             \"\\t***You are trying to partition a graph into too many parts!\\n\");\n221      return 0;\n222    }\n223  \n224    ncon = graph->ncon;\n225  \n226    /* determine the weights of the two partitions as a function of the weight of the\n227       target partition weights */\n228    WCOREPUSH;\n229    tpwgts2 = rwspacemalloc(ctrl, 2*ncon);\n230    for (i=0; i<ncon; i++) {\n231      tpwgts2[i]      = rsum((nparts>>1), tpwgts+i, ncon);\n232      tpwgts2[ncon+i] = 1.0 - tpwgts2[i];\n233    }\n234  \n235    /* perform the bisection */\n236    objval = MultilevelBisect(ctrl, graph, tpwgts2);\n237  \n238    WCOREPOP;\n239  \n240    label = graph->label;\n241    where = graph->where;\n242    for (i=0; i<nvtxs; i++)\n243      part[label[i]] = where[i] + fpart;\n244  \n245    if (nparts > 2) \n246      SplitGraphPart(ctrl, graph, &lgraph, &rgraph);\n247  \n248    /* Free the memory of the top level graph */\n249    FreeGraph(&graph);\n250  \n251    /* Scale the fractions in the tpwgts according to the true weight */\n252    for (i=0; i<ncon; i++) {\n253      wsum = rsum((nparts>>1), tpwgts+i, ncon);\n254      rscale((nparts>>1), 1.0/wsum, tpwgts+i, ncon);\n255      rscale(nparts-(nparts>>1), 1.0/(1.0-wsum), tpwgts+(nparts>>1)*ncon+i, ncon);\n256    }\n257  \n258    /* Do the recursive call */\n259    if (nparts > 3) {\n260      objval += MlevelRecursiveBisection(ctrl, lgraph, (nparts>>1), part, \n261                 tpwgts, fpart);\n262      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n263                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n264    }\n265    else if (nparts == 3) {\n266      FreeGraph(&lgraph);\n267      objval += MlevelRecursiveBisection(ctrl, rgraph, nparts-(nparts>>1), part, \n268                 tpwgts+(nparts>>1)*ncon, fpart+(nparts>>1));\n269    }\n270  \n271  \n272    return objval;\n273  }\n274  int METIS_PartGraphRecursive(idx_t *nvtxs, idx_t *ncon, idx_t *xadj, \n275            idx_t *adjncy, idx_t *vwgt, idx_t *vsize, idx_t *adjwgt, \n276            idx_t *nparts, real_t *tpwgts, real_t *ubvec, idx_t *options, \n277            idx_t *objval, idx_t *part)\n278  {\n279    int sigrval=0, renumber=0;\n280    graph_t *graph;\n281    ctrl_t *ctrl;\n282  \n283    /* set up malloc cleaning code and signal catchers */\n284    if (!gk_malloc_init()) \n285      return METIS_ERROR_MEMORY;\n286  \n287    gk_sigtrap();\n288  \n289    if ((sigrval = gk_sigcatch()) != 0) \n290      goto SIGTHROW;\n291  \n292    /* set up the run parameters */\n293    ctrl = SetupCtrl(METIS_OP_PMETIS, options, *ncon, *nparts, tpwgts, ubvec);\n294    if (!ctrl) {\n295      gk_siguntrap();\n296      return METIS_ERROR_INPUT;\n297    }\n298  \n299    /* if required, change the numbering to 0 */\n300    if (ctrl->numflag == 1) {\n301      Change2CNumbering(*nvtxs, xadj, adjncy);\n302      renumber = 1;\n303    }\n304  \n305    /* set up the graph */\n306    graph = SetupGraph(ctrl, *nvtxs, *ncon, xadj, adjncy, vwgt, vsize, adjwgt);\n307  \n308    /* allocate workspace memory */\n309    AllocateWorkSpace(ctrl, graph);\n310  \n311    /* start the partitioning */\n312    IFSET(ctrl->dbglvl, METIS_DBG_TIME, InitTimers(ctrl));\n313    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_startcputimer(ctrl->TotalTmr));\n314  \n315    iset(*nvtxs, 0, part);\n316    *objval = (*nparts == 1 ? 0 : MlevelRecursiveBisection(ctrl, graph, *nparts, part, ctrl->tpwgts, 0));\n317  \n318    IFSET(ctrl->dbglvl, METIS_DBG_TIME, gk_stopcputimer(ctrl->TotalTmr));\n319    IFSET(ctrl->dbglvl, METIS_DBG_TIME, PrintTimers(ctrl));\n320  \n321    /* clean up */\n322    FreeCtrl(&ctrl);\n323  \n324  SIGTHROW:\n325    /* if required, change the numbering back to 1 */\n326    if (renumber)\n327      Change2FNumbering(*nvtxs, xadj, adjncy, part);\n328  \n329    gk_siguntrap();\n330    gk_malloc_cleanup(0);\n331  \n332    return metis_rcode(sigrval);\n333  }\n334  ",
        "response": "-------------BEGIN REPORT----------------\nThere is 1 bug(s) in the program:\n- Bug 1, [Explanation: In the file provided, a potential divide-by-zero bug is detected at line 62. The variable mincut is assigned the value of the variable mincut divided by 2, which can lead to a divide-by-zero situation if mincut is 0.], [Trace: (Line 62, is_zero(mincut))]\n\n---------------END REPORT----------------",
        "all program size": 338,
        "input_token_cost": 0,
        "output_token_cost": 0
    }
}